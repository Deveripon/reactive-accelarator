


import { Callout, Steps, Tabs } from "nextra/components"; 

## NextJS + NestJS + Redis + NextAuth - ‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶Ö‡¶•‡ßá‡¶®‡ßç‡¶ü‡¶ø‡¶ï‡ßá‡¶∂‡¶® ‡¶∏‡¶ø‡¶∏‡ßç‡¶ü‡ßá‡¶Æ‡ßá‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶ï‡¶ø‡¶≠‡¶æ‡¶¨‡ßá ‡¶∞‡¶ø‡¶´‡ßç‡¶∞‡ßá‡¶∂ ‡¶ü‡ßã‡¶ï‡ßá‡¶® ‡¶∞‡ßã‡¶ü‡ßá‡¶∂‡¶® ‡¶Æ‡ßç‡¶Ø‡¶æ‡¶®‡ßá‡¶ú ‡¶ï‡¶∞‡¶§‡ßá ‡¶π‡ßü‡•§ 



  <Callout type='info' emoji="üí°">
    ‡¶Ø‡¶ñ‡¶®‡¶ø ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶è‡¶™‡ßç‡¶≤‡¶ø‡¶ï‡ßá‡¶∂‡¶® ‡¶•‡ßá‡¶ï‡ßá ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ï‡ßá‡¶®‡ßç‡¶° ‡¶è ‡¶∞‡¶ø‡¶ï‡ßÅ‡ßü‡ßá‡¶∏‡ßç‡¶ü ‡¶™‡¶æ‡¶†‡¶æ‡¶¨‡ßã, ‡¶∏‡ßá‡¶á ‡¶∞‡¶ø‡¶ï‡ßÅ‡ßü‡ßá‡¶∏‡ßç‡¶ü‡ßá ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶ö‡¶æ‡¶á‡¶≤‡ßá 
    ```js
    {
        credentials: "include"
    }
    ```
    ‡¶¨‡¶≤‡ßá ‡¶¶‡¶ø‡¶≤‡ßá ‡¶¨‡ßç‡¶∞‡¶æ‡¶ì‡¶ú‡¶æ‡¶∞ ‡¶Ö‡¶ü‡ßã‡¶Æ‡ßá‡¶ü‡¶ø‡¶ï ‡¶Ü‡¶Æ‡¶¶‡ßá‡¶∞ ‡¶∞‡¶ø‡¶ï‡ßÅ‡ßü‡ßá‡¶∏‡ßç‡¶ü‡ßá‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶æ‡¶∞ ‡¶∏‡¶æ‡¶á‡¶° ‡¶ï‡ßÅ‡¶ï‡¶ø ‡¶á‡¶®‡¶ï‡ßç‡¶≤‡ßÅ‡¶° ‡¶ï‡¶∞‡ßá ‡¶¶‡ßá‡ßü‡•§ 
    ‡¶Æ‡¶æ‡¶•‡¶æ‡ßü ‡¶∞‡¶æ‡¶ñ‡¶§‡ßá ‡¶π‡¶¨‡ßá ‡¶è‡¶ü‡¶æ ‡¶∂‡ßÅ‡¶ß‡ßÅ‡¶Æ‡¶æ‡¶§‡ßç‡¶∞ ‡¶ï‡ßç‡¶≤‡¶æ‡¶á‡¶®‡ßç‡¶ü ‡¶∏‡¶æ‡¶á‡¶°‡ßá‡¶á ‡¶π‡¶¨‡ßá‡•§ ‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶æ‡¶∞ ‡¶∏‡¶æ‡¶á‡¶° ‡¶™‡ßá‡¶ú ‡¶¨‡¶æ ‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶æ‡¶∞ ‡¶è‡¶ï‡¶∂‡¶® ‡¶•‡ßá‡¶ï‡ßá ‡¶è‡¶ü‡¶æ ‡¶π‡¶¨‡ßá‡¶®‡¶æ ‡•§ ‡¶∏‡ßá‡¶á ‡¶ï‡ßç‡¶∑‡ßá‡¶§‡ßç‡¶∞‡ßá ‡¶Ü‡¶Æ‡¶æ‡¶∞‡¶æ 
    ```js
    {
    header:{
        Authorization : "" // ‡¶Ö‡¶•‡¶¨‡¶æ ‡¶Ö‡¶®‡ßç‡¶Ø ‡¶Ø‡ßá‡¶ï‡ßã‡¶® ‡¶π‡ßá‡¶°‡¶æ‡¶∞ ‡¶™‡¶∞‡¶™‡¶æ‡¶∞‡ßç‡¶ü‡¶ø‡¶∞ ‡¶Æ‡¶æ‡¶ß‡ßç‡¶Ø‡¶Æ‡ßá ‡¶Æ‡ßç‡¶Ø‡¶æ‡¶®‡ßÅ‡ßü‡¶æ‡¶≤‡¶ø ‡¶°‡¶æ‡¶ü‡¶æ ‡¶™‡¶æ‡¶†‡¶æ‡¶§‡ßá ‡¶π‡¶¨‡ßá 
    }
    }
    ```
    ‡¶è‡¶∞ ‡¶Æ‡¶æ‡¶ß‡ßç‡¶Ø‡¶Æ‡ßá ‡¶Æ‡ßç‡¶Ø‡¶æ‡¶®‡ßÅ‡ßü‡¶æ‡¶≤‡¶ø ‡¶°‡¶æ‡¶ü‡¶æ ‡¶™‡¶æ‡¶†‡¶æ‡¶§‡ßá ‡¶π‡¶¨‡ßá 
</Callout>






**‡¶è‡¶á ‡¶ó‡¶æ‡¶á‡¶°‡ßá ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶è‡¶ï‡¶ü‡¶ø ‡¶ï‡¶Æ‡¶™‡ßç‡¶≤‡¶ø‡¶ü ‡¶´‡ßÅ‡¶≤‡¶∏‡ßç‡¶ü‡ßç‡¶Ø‡¶æ‡¶ï ‡¶Ö‡¶•‡ßá‡¶®‡ßç‡¶ü‡¶ø‡¶ï‡ßá‡¶∂‡¶® ‡¶∏‡¶ø‡¶∏‡ßç‡¶ü‡ßá‡¶Æ ‡¶¨‡¶æ‡¶®‡¶æ‡¶¨‡ßã ‡¶Ø‡ßá‡¶ñ‡¶æ‡¶®‡ßá‡¶É**

- NextJS ‡¶´‡ßç‡¶∞‡¶®‡ßç‡¶ü‡¶è‡¶®‡ßç‡¶° ‡¶•‡¶æ‡¶ï‡¶¨‡ßá
- NestJS ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ï‡¶è‡¶®‡ßç‡¶° ‡¶•‡¶æ‡¶ï‡¶¨‡ßá
- NextAuth ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá ‡¶Æ‡¶æ‡¶≤‡ßç‡¶ü‡¶ø‡¶™‡¶≤ ‡¶™‡ßç‡¶∞‡¶≠‡¶æ‡¶á‡¶°‡¶æ‡¶∞ (Credentials + OAuth) ‡¶∏‡¶æ‡¶™‡ßã‡¶∞‡ßç‡¶ü ‡¶•‡¶æ‡¶ï‡¶¨‡ßá
- Redis ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá ‡¶ü‡ßã‡¶ï‡ßá‡¶® ‡¶∏‡ßç‡¶ü‡ßã‡¶∞‡ßá‡¶ú ‡¶è‡¶¨‡¶Ç ‡¶ü‡ßã‡¶ï‡ßá‡¶® ‡¶∞‡ßã‡¶ü‡ßá‡¶∂‡¶® ‡¶∏‡¶ø‡¶∏‡ßç‡¶ü‡ßá‡¶Æ ‡¶•‡¶æ‡¶ï‡¶¨‡ßá ‡¶è‡¶¨‡¶Ç 
- ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶ï‡ßç‡¶∏‡ßá‡¶∏ ‡¶è‡¶¨‡¶Ç ‡¶∞‡¶ø‡¶´‡ßç‡¶∞‡ßá‡¶∂ ‡¶ü‡ßã‡¶ï‡ßá‡¶® ‡¶™‡ßÅ‡¶∞‡ßã‡¶™‡ßÅ‡¶∞‡¶ø ‡¶π‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡ßá‡¶≤ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶¨‡ßá


**‡¶è‡¶§‡ßá ‡¶Ü‡¶Æ‡¶æ‡¶¶‡ßá‡¶∞ ‡¶Ø‡ßá‡¶∏‡¶¨ ‡¶ü‡ßÅ‡¶≤‡¶∏‡ßá‡¶∞ ‡¶™‡ßç‡¶∞‡ßü‡ßã‡¶ú‡¶® ‡¶™‡¶∞‡¶¨‡ßá‡¶É** 
- Node.js (16+)
- Upstash Redis ‡¶è‡¶ï‡¶æ‡¶ä‡¶®‡ßç‡¶ü 
- Prisma 
- Mongodb (Prisma ‡¶è‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶°‡¶æ‡¶ü‡¶æ‡¶¨‡ßá‡¶∏ ‡¶π‡¶ø‡¶∏‡ßá‡¶¨‡ßá ‡¶¨‡ßç‡¶Ø‡¶æ‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø) 


<Steps>
### ‡¶∏‡ßç‡¶ü‡ßá‡¶™-‡ß¶‡ßß‡¶É  ‡¶™‡ßç‡¶∞‡¶Ø‡¶º‡ßã‡¶ú‡¶®‡ßÄ‡¶Ø‡¶º ‡¶™‡ßç‡¶Ø‡¶æ‡¶ï‡ßá‡¶ú ‡¶á‡¶®‡¶∏‡ßç‡¶ü‡¶≤

```bash
    npm install next-auth@latest @upstash/redis jwt-decode
```


### ‡¶∏‡ßç‡¶ü‡ßá‡¶™-‡ß¶‡ß®‡¶É  ¬†Nest.js ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ï‡¶è‡¶®‡ßç‡¶°‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø Prisma ‡¶Æ‡¶°‡ßá‡¶≤ ‡¶∏‡ßá‡¶ü-‡¶Ü‡¶™ ‡¶ï‡¶∞‡¶æ‡•§ 
```js

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider     = "mongodb"
  url          = env("DATABASE_URL")
  relationMode = "prisma"
}

model User {
  id           String       @id @default(auto()) @map("_id") @db.ObjectId
  email        String       @unique
  name         String?      @default("")
  phone        String?      @default("")
  image        Json?        @default("{}")
  password     String?      // Made optional for OAuth users
  refreshToken String?
  isVerified   Boolean      @default(false)
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt
  
  // OAuth related fields
  emailVerified DateTime?

  // Relations
  accounts     Account[]    // Add relation to accounts
}

// New model for OAuth accounts
model Account {
  id                String  @id @default(auto()) @map("_id") @db.ObjectId
  userId            String  @db.ObjectId
  provider          String  // 'google', 'twitter', 'apple', etc.
  providerAccountId String  // ID from the provider
  type              String  @default("oauth")
  
  // OAuth tokens
  access_token      String?
  refresh_token     String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  
  // Relation to user
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Ensure provider + providerAccountId is unique
  @@unique([provider, providerAccountId])
}

```
‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶è‡¶ï‡¶ü‡¶ø `User` ‡¶è‡¶®‡ßç‡¶° `Acounts` ‡¶®‡¶æ‡¶Æ‡ßá ‡¶¶‡ßÅ‡¶á‡¶ü‡¶æ ‡¶Æ‡¶°‡ßá‡¶≤ ‡¶¨‡¶æ‡¶®‡¶æ‡¶ö‡ßç‡¶õ‡¶ø ‡¶∏‡ßá‡¶ñ‡¶æ‡¶®‡ßá ‡¶á‡¶â‡¶ú‡¶æ‡¶∞ ‡¶Ø‡¶ñ‡¶® `Credentials` ‡¶¶‡¶ø‡ßü‡ßá ‡¶∏‡¶æ‡¶á‡¶®-‡¶á‡¶® ‡¶ï‡¶∞‡¶¨‡ßá ‡¶§‡¶ñ‡¶® ‡¶∏‡ßá‡¶á ‡¶°‡¶æ‡¶ü‡¶æ ‡¶ó‡ßÅ‡¶≤‡ßã `User` ‡¶ü‡ßá‡¶¨‡¶ø‡¶≤‡ßá ‡¶∏‡ßá‡¶≠ ‡¶π‡¶¨‡ßá ‡¶è‡¶¨‡¶Ç ‡¶á‡¶â‡¶ú‡¶æ‡¶∞ ‡¶Ø‡¶ñ‡¶® `OAuth Provider` ‡¶¶‡¶ø‡ßü‡ßá ‡¶∏‡¶æ‡¶á‡¶®-‡¶á‡¶® ‡¶ï‡¶∞‡¶¨‡ßá ‡¶§‡¶ñ‡¶® ‡¶∏‡ßá‡¶á ‡¶™‡ßç‡¶∞‡¶≠‡¶æ‡¶á‡¶°‡¶æ‡¶∞ ‡¶è‡¶¨‡¶Ç ‡¶è‡¶ï‡¶æ‡¶ä‡¶£‡ßç‡¶ü ‡¶è‡¶∞ ‡¶á‡¶®‡¶´‡¶∞‡¶Æ‡ßá‡¶∂‡¶® ‡¶ó‡ßÅ‡¶≤‡ßã `Acounts` ‡¶ü‡ßá‡¶¨‡¶ø‡¶≤‡ßá ‡¶∏‡ßá‡¶≠ ‡¶π‡¶¨‡ßá‡•§
‡¶è‡¶¨‡¶Ç ‡¶¶‡ßÅ‡¶á‡¶ü‡¶æ ‡¶ü‡ßá‡¶¨‡¶ø‡¶≤‡ßá ‡¶∞‡¶ø‡¶≤‡ßá‡¶∂‡¶® ‡¶ï‡ßç‡¶∞‡¶ø‡ßü‡ßá‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá, ‡¶Ø‡¶æ‡¶§‡ßá ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶Ø‡ßá‡¶ï‡ßã‡¶® ‡¶∏‡¶Æ‡ßü ‡¶∞‡¶ø‡¶≤‡ßá‡¶∂‡¶®‡¶æ‡¶≤ ‡¶°‡ßá‡¶ü‡¶æ‡¶ó‡ßÅ‡¶≤‡ßã ‡¶è‡¶ï‡ßç‡¶∏‡ßá‡¶∏ ‡¶ï‡¶∞‡ßá‡¶§ ‡¶™‡¶æ‡¶∞‡¶ø‡•§ 


### ‡¶∏‡ßç‡¶ü‡ßá‡¶™-‡ß¶‡ß©‡¶É ‡¶Ö‡¶•‡ßá‡¶®‡¶ü‡¶ø‡¶ï‡ßá‡¶∂‡¶®‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ï‡¶è‡¶®‡ßç‡¶°‡ßá‡¶∞ `AuthController ` ‡¶ì `AuthService` ‡¶∏‡ßá‡¶ü‡¶Ü‡¶™ ‡¶ï‡¶∞‡¶æ 

‡¶è‡¶ñ‡¶® ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶§‡ßá ‡¶á‡¶â‡¶ú‡¶æ‡¶∞‡¶ï‡ßá ‡¶∏‡¶æ‡¶á‡¶®-‡¶á‡¶® ‡¶è‡¶®‡ßç‡¶° ‡¶∏‡¶æ‡¶á‡¶®-‡¶Ü‡¶™ ‡¶ï‡¶∞‡¶æ‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶ø, ‡¶è‡¶¨‡¶Ç ‡¶ü‡ßã‡¶ï‡ßá‡¶® ‡¶Æ‡ßá‡¶®‡ßá‡¶ú ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶ø ‡¶§‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø 

`AuthController ` ‡¶ì `AuthService` ‡¶∏‡ßá‡¶ü‡¶Ü‡¶™ ‡¶ï‡¶∞‡¶æ‡¶¨‡ßã‡•§


<Tabs items={["AuthController.ts", "AuthService.ts"]}>
    <Tabs.Tab>
       ```js filename="auth/authController.ts"
                import {
                Body,
                Controller,
                HttpException,
                HttpStatus,
                Post,
                Res,
                } from '@nestjs/common';
                import { Response } from 'express';
                import { AuthService } from './auth.service';
                import { refreshTokenDto, signInDto, signUpDto } from './dto';

                import { SendOtpDto } from './dto/send-otp.dto';
                import { VerifyOtpDto } from './dto/verify-otp.dto';

                class SignInResponse {
                id: string;
                name: string | null;
                email: string;
                accessToken: string;
                refreshToken: string;
                }

                class RefreshTokenResponse {
                access_token: string;
                refresh_token: string;
                }

                @Controller('api/auth')
                export class AuthController {
                constructor(private authService: AuthService) {}

                // Sign Up with Credentials
                @Post('signup')
                async signUp(@Body() dto: signUpDto) {
                    return this.authService.signUpWithCredentials(dto);
                }

                // Sign In with Credentials
                @Post('signin')
                async signIn(
                    @Body() dto: signInDto,
                    @Res({ passthrough: true }) res: Response,
                ): Promise<any> {
                    const response = await this.authService.signInWithCredentials(dto);
                    res.cookie('refresh_token', response.refreshToken, {
                    httpOnly: true,
                    secure: process.env.NODE_ENV !== 'development',
                    sameSite: 'none',
                    maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
                    });
                    return response;
                }

                // New endpoint for OAuth users
                @Post('oauth')
                async handleOAuthLogin(
                    @Body() oauthData: any,
                    @Res({ passthrough: true }) res: Response,
                ): Promise<any> {
                    try {
                    const response = await this.authService.handleOAuthLogin(oauthData);
                    res.cookie('refresh_token', response.refreshToken, {
                        httpOnly: true,
                        secure: process.env.NODE_ENV !== 'development',
                        sameSite: 'none',
                        maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
                    });
                    return response;
                    } catch (error) {
                    throw new HttpException(
                        error.message || 'OAuth login failed',
                        HttpStatus.UNAUTHORIZED,
                    );
                    }
                }

                // Refresh Token
                @Post('refresh-token')
                async getRefreshToken(
                    @Body() dto: refreshTokenDto,
                    @Res({ passthrough: true }) res: Response,
                ): Promise<RefreshTokenResponse> {
                    const new_tokens = await this.authService.refreshToken(
                    dto.refresh_token,
                    dto.provider,
                    );
                    res.cookie('refresh_token', new_tokens.refresh_token, {
                    httpOnly: true,
                    secure: process.env.NODE_ENV !== 'development',
                    sameSite: 'none',
                    maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
                    });
                    return new_tokens;
                }
                }

        ```
    </Tabs.Tab>
    <Tabs.Tab>
        ```js
              import {
                BadRequestException,
                ForbiddenException,
                Injectable,
                UnauthorizedException,
                } from '@nestjs/common';
                import { ConfigService } from '@nestjs/config';
                import { JwtService } from '@nestjs/jwt';
                import { PrismaClientKnownRequestError } from '@prisma/client/runtime/library';
                import * as bcrypt from 'bcrypt';
                import { PrismaService } from 'src/prisma/prisma.service';
                import { MailService } from '../mail/mail.service';
                import { OtpService } from '../otp/otp.service';
                import { signInDto, signUpDto } from './dto';
                import { SendOtpDto } from './dto/send-otp.dto';
                import { VerifyOtpDto } from './dto/verify-otp.dto';
                @Injectable({})
                export class AuthService {
                constructor(
                    private prisma: PrismaService,
                    private jwtService: JwtService,
                    private config: ConfigService,
                ) {}

                // ===============generate tokens================
                async getToken(id: string, email: string) {
                    const accessToken = await this.jwtService.signAsync(
                    { sub: id, email },
                    {
                        expiresIn: this.config.get('ACCESS_TOKEN_EXPIRES_IN'),
                        secret: this.config.get('JWT_ACCESS_SECRET'),
                    },
                    );
                    const refreshToken = await this.jwtService.signAsync(
                    { sub: id, email },
                    {
                        expiresIn: this.config.get('REFRESH_TOKEN_EXPIRES_IN'),
                        secret: this.config.get('JWT_REFRESH_SECRET'),
                    },
                    );

                    return {
                    access_token: accessToken,
                    refresh_token: refreshToken,
                    };
                }

                // ===================Sign Up With Credentials===========
                async signUpWithCredentials(dto: signUpDto) {
                    try {
                    const hashedPassword = await bcrypt.hashSync(dto.password, 10);
                    const user = await this.prisma.user.create({
                        data: {
                        ...dto,
                        password: hashedPassword,
                        },
                        select: {
                        id: true,
                        name: true,
                        email: true,
                        password: true,
                        createdAt: true,
                        updatedAt: true,
                        },
                    });

                    return {
                        message: 'User Created Successfully',
                        data: user,
                    };
                    } catch (error) {
                    if (error instanceof PrismaClientKnownRequestError) {
                        if (error.code === 'P2002') {
                        throw new ForbiddenException('This email is already used');
                        }
                    }
                    }
                }

                // ===================Sign In With Credentials====================
                async signInWithCredentials(dto: signInDto) {
                    // find the user with credentials
                    const user = await this.prisma.user.findUnique({
                    where: { email: dto.email },
                    });

                    console.log(`requested to sign in`, user);

                    if (!user) {
                    throw new UnauthorizedException('Invalid credentials');
                    }

                    if (!user?.password) {
                    throw new UnauthorizedException('Invalid credentials');
                    }

                    const isPasswordValid = bcrypt.compareSync(dto.password, user?.password);
                    console.log(`password is valid`, isPasswordValid);

                    if (!isPasswordValid) {
                    throw new UnauthorizedException('Invalid credentials');
                    }

                    // Generate tokens
                    // generate jwt and hash the refresh token and save to db
                    const tokens = await this.getToken(user?.id, user?.email);

                    // Update user with refresh token
                    await this.prisma.user.update({
                    where: { id: user.id },
                    data: { refreshToken: tokens.refresh_token },
                    });

                    return {
                    id: user.id,
                    name: user.name,
                    email: user.email,
                    accessToken: tokens.access_token,
                    refreshToken: tokens.refresh_token,
                    };
                }

                // Sign in With OAuth
                async handleOAuthLogin(oauthData: any) {
                    const { provider, providerAccountId, profile, tokens } = oauthData;

                    try {
                    // Check if user already exists with this provider account
                    let user = await this.prisma.user.findFirst({
                        where: {
                        accounts: {
                            some: {
                            provider: provider,
                            providerAccountId: providerAccountId,
                            },
                        },
                        },
                        include: {
                        accounts: true,
                        },
                    });

                    // If no user with this OAuth account, check by email
                    if (!user && profile.email) {
                        user = await this.prisma.user.findUnique({
                        where: { email: profile.email },
                        include: {
                            accounts: true,
                        },
                        });
                    }

                    // If user exists, update the OAuth account
                    if (user) {
                        // Check if this provider account already exists
                        const existingAccount = user.accounts.find(
                        (account) =>
                            account.provider === provider &&
                            account.providerAccountId === providerAccountId,
                        );

                        if (!existingAccount) {
                        // Create new provider account for existing user
                        await this.prisma.account.create({
                            data: {
                            userId: user.id,
                            provider,
                            providerAccountId,
                            access_token: tokens.access_token,
                            refresh_token: tokens.refresh_token,
                            expires_at: tokens.expires_at,
                            },
                        });
                        } else {
                        // Update existing account tokens
                        await this.prisma.account.update({
                            where: { id: existingAccount.id },
                            data: {
                            access_token: tokens.access_token,
                            refresh_token: tokens.refresh_token,
                            expires_at: tokens.expires_at,
                            },
                        });
                        }
                    } else {
                        // Create new user and account
                        user = await this.prisma.user.create({
                        data: {
                            name: profile.name || '',
                            email: profile.email,
                            image: profile.image
                            ? JSON.parse(JSON.stringify(profile.image))
                            : {},
                            isVerified: true, // Auto-verify OAuth users
                            emailVerified: new Date(),
                            accounts: {
                            create: {
                                provider,
                                providerAccountId,
                                access_token: tokens.access_token,
                                refresh_token: tokens.refresh_token,
                                expires_at: tokens.expires_at,
                            },
                            },
                        },
                        include: {
                            accounts: true,
                        },
                        });
                    }

                    // Generate JWT tokens for the user
                    const generatedTokens = await this.getToken(user?.id, user?.email);

                    // Update user with refresh token
                    await this.prisma.user.update({
                        where: { id: user.id },
                        data: { refreshToken: generatedTokens.refresh_token },
                    });

                    return {
                        id: user.id,
                        name: user.name,
                        email: user.email,
                        accessToken: generatedTokens.access_token,
                        refreshToken: generatedTokens.refresh_token,
                    };
                    } catch (error) {
                    console.error('OAuth login error:', error);
                    throw new UnauthorizedException('OAuth authentication failed');
                    }
                }

                // ========================Get Refresh Token========================
                async refreshToken(refreshToken: string, provider?: string) {
                    try {
                    // Find user by refresh token
                    const user = await this.prisma.user.findFirst({
                        where: { refreshToken },
                    });

                    if (!user) {
                        throw new UnauthorizedException('Invalid refresh token');
                    }

                    // Generate new tokens
                    const tokens = await this.getToken(user?.id, user?.email);

                    // Update the refresh token in the database
                    await this.prisma.user.update({
                        where: { id: user.id },
                        data: { refreshToken: tokens.refresh_token },
                    });

                    return {
                        access_token: tokens.access_token,
                        refresh_token: tokens.refresh_token,
                    };
                    } catch (error) {
                    console.error('Refresh token error:', error);
                    throw new UnauthorizedException('Failed to refresh token');
                    }
                }
               
        ```
     
    </Tabs.Tab>

</Tabs>


### ‡¶∏‡ßç‡¶ü‡ßá‡¶™-‡ß¶‡ß™‡¶É ‡¶´‡ßç‡¶∞‡¶®‡ßç‡¶ü‡¶è‡¶®‡ßç‡¶°‡ßá ‡¶è‡¶®‡¶≠‡¶æ‡¶á‡¶∞‡¶®‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶≠‡ßç‡¶Ø‡ßá‡¶∞‡¶ø‡ßü‡ßá‡¶¨‡¶≤ ‡¶∏‡ßá‡¶ü ‡¶ï‡¶∞‡¶æ 

```js
# NextAuth
AUTH_SECRET=your_auth_secret
NEXTAUTH_URL=http://localhost:3000

# API URL
NEXT_PUBLIC_API_BASE_URL=http://localhost:3333

# OAuth Providers
GOOGLE_CLIENT_ID=your_google_client_id
GOOGLE_CLIENT_SECRET=your_google_client_secret

GITHUB_CLIENT_ID=your_github_client_id
GITHUB_CLIENT_SECRET=your_github_client_secret

TWITTER_CLIENT_ID=your_twitter_client_id
TWITTER_CLIENT_SECRET=your_twitter_client_secret

APPLE_ID=your_apple_id
APPLE_SECRET=your_apple_secret

# Redis
UPSTASH_REDIS_URL=your_redis_url
UPSTASH_REDIS_TOKEN=your_redis_token
```


### ‡¶∏‡ßç‡¶ü‡ßá‡¶™-‡ß¶‡ß´‡¶É ‡¶´‡ßç‡¶∞‡¶®‡ßç‡¶ü‡¶è‡¶®‡ßç‡¶°‡ßá `auth.config.js` ‡¶´‡¶æ‡¶á‡¶≤ ‡¶∏‡ßá‡¶ü‡¶Ü‡¶™ ‡¶ï‡¶∞‡¶æ 

```js
    // frontend/auth.config.js
    const authConfig = {
        session: {
            strategy: "jwt",
        },
        providers: [],
    };
    export default authConfig;
```

### ‡¶∏‡ßç‡¶ü‡ßá‡¶™-‡ß¶‡ß¨‡¶É ‡¶´‡ßç‡¶∞‡¶®‡ßç‡¶ü‡¶è‡¶®‡ßç‡¶°‡ßá `auth.js` ‡¶´‡¶æ‡¶á‡¶≤ ‡¶∏‡ßá‡¶ü‡¶Ü‡¶™ ‡¶ï‡¶∞‡¶æ 

```js
import { Redis } from "@upstash/redis";
import { jwtDecode } from "jwt-decode";
import NextAuth from "next-auth";
import AppleProvider from "next-auth/providers/apple";
import CredentialsProvider from "next-auth/providers/credentials";
import GithubProvider from "next-auth/providers/github";
import GoogleProvider from "next-auth/providers/google";
import TwitterProvider from "next-auth/providers/twitter";
import authConfig from "./auth.config";

// Initialize Redis client
const redis = new Redis({
    url: process.env.UPSTASH_REDIS_URL,
    token: process.env.UPSTASH_REDIS_TOKEN,
});

/**
 * Fetches token from Redis storage
 */
async function getTokenFromRedis(userId, provider) {
    try {
        const key = `user:${userId}:${provider}:tokens`;
        const tokens = await redis.get(key);
        return tokens || null;
    } catch (error) {
        console.error("‚ùå [REDIS GET ERROR]:", error);
        return null;
    }
}

/**
 * Stores token in Redis storage
 */
async function storeTokenInRedis(userId, provider, tokens) {
    try {
        const key = `user:${userId}:${provider}:tokens`;
        // Set tokens with expiry of 7 days
        await redis.set(key, tokens, { ex: 60 * 60 * 24 * 7 });
        console.log(`üíæ [REDIS STORE] Tokens stored for user ${userId}`);
    } catch (error) {
        console.error("‚ùå [REDIS STORE ERROR]:", error);
    }
}

/**
 * Removes token from Redis storage
 */
async function removeTokenFromRedis(userId, provider) {
    try {
        const key = `user:${userId}:${provider}:tokens`;
        await redis.del(key);
        console.log(`üóëÔ∏è [REDIS DELETE] Tokens removed for user ${userId}`);
    } catch (error) {
        console.error("‚ùå [REDIS DELETE ERROR]:", error);
    }
}

/**
 * Refreshes the access token when it's expired
 */
async function refreshAccessToken(token) {
    console.log("üîÅ [REFRESH TOKEN] Trying to refresh access token...");

    // Check if we have fresher tokens in Redis
    if (token.id && token.provider) {
        const storedTokens = await getTokenFromRedis(token.id, token.provider);
        if (
            storedTokens &&
            storedTokens.accessTokenExpires > token.accessTokenExpires
        ) {
            console.log("üîÑ [REFRESH TOKEN] Using fresher token from Redis");
            return {
                ...token,
                ...storedTokens,
            };
        }
    }

    // Use the refresh token from the token object
    const refreshTokenToUse = token.refreshToken;
    if (!refreshTokenToUse) {
        console.error("‚ùå [REFRESH TOKEN] No refresh token available");
        return {
            ...token,
            error: "RefreshTokenNotAvailable",
        };
    }

    try {
        const response = await fetch(
            `${process.env.NEXT_PUBLIC_API_BASE_URL}/auth/refresh-token`,
            {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                },
                body: JSON.stringify({
                    refresh_token: refreshTokenToUse,
                    provider: token.provider,
                }),
            }
        );

        const refreshedTokens = await response.json();

        if (!response.ok) {
            console.error("‚ùå [REFRESH TOKEN FAILED]:", refreshedTokens);
            throw refreshedTokens;
        }

        const decodedToken = jwtDecode(refreshedTokens.access_token);
        const expiresAt = decodedToken.exp * 1000;

        console.log(
            "‚úÖ [REFRESH TOKEN] New access token expires at:",
            new Date(expiresAt)
        );

        const updatedToken = {
            ...token,
            accessToken: refreshedTokens.access_token,
            refreshToken: refreshedTokens.refresh_token,
            accessTokenExpires: expiresAt,
        };

        // Store the new tokens in Redis
        if (token.id && token.provider) {
            await storeTokenInRedis(token.id, token.provider, {
                accessToken: refreshedTokens.access_token,
                refreshToken: refreshedTokens.refresh_token,
                accessTokenExpires: expiresAt,
            });
        }

        return updatedToken;
    } catch (error) {
        console.error("‚ùå [REFRESH TOKEN ERROR]:", error);
        return {
            ...token,
            error: "RefreshAccessTokenError",
        };
    }
}

export const { handlers, signIn, signOut, auth } = NextAuth({
    secret: process.env.AUTH_SECRET,
    ...authConfig,
    providers: [
        CredentialsProvider({
            id: "credentials",
            name: "Credentials",
            credentials: {
                email: {},
                password: {},
            },
            async authorize(credentials) {
                console.log(
                    "üîê [AUTHORIZE] Login attempt with email:",
                    credentials?.email
                );

                if (!credentials?.email || !credentials?.password) {
                    console.log("‚ùå [AUTHORIZE] Missing email or password");
                    throw new Error("Invalid credentials");
                }

                return {
                    ...credentials,
                    provider: "credentials",
                };
            },
        }),
        GoogleProvider({
            clientId: process.env.GOOGLE_CLIENT_ID,
            clientSecret: process.env.GOOGLE_CLIENT_SECRET,
            authorization: {
                params: {
                    prompt: "consent",
                    access_type: "offline",
                    response_type: "code",
                },
            },
        }),
        TwitterProvider({
            clientId: process.env.TWITTER_CLIENT_ID,
            clientSecret: process.env.TWITTER_CLIENT_SECRET,
            version: "2.0",
        }),
        AppleProvider({
            clientId: process.env.APPLE_ID,
            clientSecret: process.env.APPLE_SECRET,
        }),
        GithubProvider({
            clientId: process.env.GITHUB_CLIENT_ID,
            clientSecret: process.env.GITHUB_CLIENT_SECRET,
        }),
    ],

    callbacks: {
        async signIn({ user, account, profile }) {
            console.log(
                "üëã [SIGN IN] User signing in via:",
                account?.provider || "unknown"
            );

            // Skip for credentials provider - already handled in authorize callback
            if (account?.provider === "credentials") {
                return true;
            }

            try {
                // Process OAuth login through NestJS backend
                const res = await fetch(
                    `${process.env.NEXT_PUBLIC_API_BASE_URL}/auth/oauth`,
                    {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            provider: account.provider,
                            providerAccountId: account.providerAccountId,
                            profile: {
                                name: user.name,
                                email: user.email,
                                image: user.image,
                            },
                            tokens: {
                                access_token: account.access_token,
                                refresh_token: account.refresh_token,
                                expires_at: account.expires_at,
                            },
                        }),
                    }
                );

                const response = await res.json();

                if (!res.ok) {
                    console.error(
                        "‚ùå [SIGN IN] OAuth user registration failed:",
                        response.message
                    );
                    return false;
                }

                // Update the user object with data from NestJS backend
                user.id = response.id;
                user.accessToken = response.accessToken;
                user.refreshToken = response.refreshToken;
                user.provider = account.provider;

                // Store the tokens in Redis right away
                const decoded = jwtDecode(response.accessToken);
                const expiresAt = decoded.exp * 1000;

                await storeTokenInRedis(response.id, account.provider, {
                    accessToken: response.accessToken,
                    refreshToken: response.refreshToken,
                    accessTokenExpires: expiresAt,
                });

                return true;
            } catch (error) {
                console.error("‚ùå [SIGN IN] OAuth processing error:", error);
                return false;
            }
        },

        async jwt({ token, user, account }) {
            console.log("üîë [JWT CALLBACK] Started");

            // Initial sign-in
            if (user) {
                console.log("üë§ [JWT CALLBACK] New sign-in");

                let accessTokenExpires;

                // For OAuth providers
                if (account && account.provider !== "credentials") {
                    // OAuth token expiry calculation
                    accessTokenExpires = account.expires_at
                        ? account.expires_at * 1000
                        : Date.now() + 3600 * 1000;
                }
                // For credentials provider
                else {
                    try {
                        const decoded = jwtDecode(user.accessToken);
                        accessTokenExpires = decoded.exp * 1000;
                    } catch (error) {
                        console.error("‚ùå [JWT DECODE ERROR]:", error);
                        accessTokenExpires = Date.now() + 3600 * 1000; // Default to 1 hour if decode fails
                    }
                }

                console.log(
                    "‚úÖ [JWT CALLBACK] Token expires at:",
                    new Date(accessTokenExpires)
                );

                // Store tokens in Redis during sign-in
                if (user.id) {
                    await storeTokenInRedis(user.id, user.provider, {
                        accessToken: user.accessToken,
                        refreshToken: user.refreshToken,
                        accessTokenExpires: accessTokenExpires,
                    });
                }

                return {
                    ...token,
                    accessToken: user.accessToken,
                    refreshToken: user.refreshToken,
                    accessTokenExpires: accessTokenExpires,
                    id: user.id,
                    email: user.email,
                    name: user.name,
                    provider: user.provider,
                };
            }

            // For subsequent requests, check Redis for fresher tokens
            if (token.id && token.provider) {
                const storedTokens = await getTokenFromRedis(
                    token.id,
                    token.provider
                );
                if (
                    storedTokens &&
                    storedTokens.accessTokenExpires > token.accessTokenExpires
                ) {
                    console.log("üîÑ [JWT] Using fresher token from Redis");
                    return {
                        ...token,
                        ...storedTokens,
                    };
                }
            }

            // Check if token is expired
            if (
                token.accessTokenExpires &&
                Date.now() >= token.accessTokenExpires - 30000
            ) {
                console.log(
                    "‚ö†Ô∏è [JWT CALLBACK] Token expired or close to expiry"
                );
                return await refreshAccessToken(token);
            }

            return token;
        },

        async session({ session, token }) {
            console.log("üì¶ [SESSION CALLBACK] Building session");

            // Transfer token data to session
            session.accessToken = token.accessToken;
            session.refreshToken = token.refreshToken;
            session.accessTokenExpires = token.accessTokenExpires;
            session.provider = token.provider;
            session.user = {
                id: token.id,
                name: token.name,
                email: token.email,
                provider: token.provider,
            };

            if (token?.error) {
                console.error(
                    "‚ö†Ô∏è [SESSION CALLBACK] Error in token:",
                    token.error
                );
                session.error = token.error;
            }

            return session;
        },
    },

    events: {
        async signIn(message) {
            console.log("üö™ [EVENT] User signed in:", message.user.email);
        },
        async signOut({ token }) {
            console.log("üëã [EVENT] User signed out");
            // Clear tokens from Redis on sign out
            if (token?.id && token?.provider) {
                await removeTokenFromRedis(token.id, token.provider);
            }
        },
    },

    jwt: {
        maxAge: 60 * 60 * 24 * 7, // 7 days
    },
    pages: {
        signIn: "/sign-in",
        error: "/auth/error",
    },
    debug: process.env.NODE_ENV === "development",
});

```
### ‡¶∏‡ßç‡¶ü‡ßá‡¶™-‡ß¶‡ß≠‡¶É `Next.js` ‡¶ï‡¶®‡¶´‡¶ø‡¶ó‡¶æ‡¶∞‡ßá‡¶∂‡¶® ‡¶Ü‡¶™‡¶°‡ßá‡¶ü ‡¶ï‡¶∞‡¶æ 

```js
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  swcMinify: true,
  env: {
    UPSTASH_REDIS_URL: process.env.UPSTASH_REDIS_URL,
    UPSTASH_REDIS_TOKEN: process.env.UPSTASH_REDIS_TOKEN,
  },
}

module.exports = nextConfig
```

### ‡¶∏‡ßç‡¶ü‡ßá‡¶™-‡ß¶‡ßÆ‡¶É ‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶æ‡¶∞ ‡¶∏‡ßç‡¶ü‡¶æ‡¶∞‡ßç‡¶ü ‡¶π‡¶ì‡ßü‡¶æ‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶∏‡¶æ‡¶•‡ßá ‡¶Æ‡¶ø‡¶°‡¶≤‡¶ì‡ßü‡ßç‡¶Ø‡¶æ‡¶∞‡ßá‡¶∞ ‡¶Æ‡¶æ‡¶ß‡ßç‡¶Ø‡¶Æ‡ßá `Redis` ‡¶ï‡¶æ‡¶®‡ßá‡¶ï‡¶∂‡¶® ‡¶∏‡ßá‡¶ü ‡¶ï‡¶∞‡¶æ ‡•§ 


```js filename="middleware.js"
//  middleware.js
import { Redis } from "@upstash/redis";
export async function middleware() {
  try {
    const redis = new Redis({
      url: process.env.UPSTASH_REDIS_URL,
      token: process.env.UPSTASH_REDIS_TOKEN,
    });

    await redis.ping();
    console.log("‚úÖ Redis connection successful");
  } catch (error) {
    console.error("‚ùå Redis connection failed:", error);
  }
}
```

</Steps>


‡¶è‡¶á ‡¶∏‡¶¨‡¶ó‡ßÅ‡¶≤‡ßã ‡¶∏‡ßç‡¶ü‡ßá‡¶™ ‡¶´‡¶≤‡ßã ‡¶ï‡¶∞‡¶≤‡ßá ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶è‡¶ï‡¶ü‡¶æ ‡¶™‡¶æ‡¶∞‡¶´‡ßá‡¶ï‡ßç‡¶ü‡¶≤‡¶ø ‡¶ì‡ßü‡¶æ‡¶∞‡ßç‡¶ï‡¶ø‡¶Ç ‡¶∏‡¶≤‡¶ø‡¶â‡¶∂‡¶® ‡¶™‡ßá‡ßü‡ßá ‡¶Ø‡¶æ‡¶¨‡ßã‡•§ 
