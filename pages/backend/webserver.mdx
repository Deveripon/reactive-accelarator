import Webserver from "@/components/svgs/webserver.jsx"

###  ওয়েব সার্ভার কি?

Web Server হলো একটা software (কখনও কখনও hardware সহ) যেটা client (browser, app) থেকে আসা request নিয়ে, সঠিক response (যেমন HTML, CSS, JS, Image, Data ইত্যাদি) ফেরত পাঠায়।

**সহজভাবে বললে:**
Browser এ আপনি যখন https://example.com লিখেন, তখন সেটা একটা request পাঠায়। Web Server সেই request গ্রহণ করে, server-এর ফাইল বা database থেকে data বের করে, আবার আপনার browser-এ পাঠায়।
Browser সেই data render করে ওয়েবসাইট হিসেবে দেখায়।

**আমরা যদি স্টেপ বাই স্টেপ বুঝতে চেষ্টা করি তাহলেঃ** 

১ । **Client Request:**

User ব্রাউজারে URL টাইপ করলো → https://example.com

এই URL আসলে server-এর কাছে একটা request পাঠায়।


২ । **Server Listen করে:**

Web server একটা নির্দিষ্ট port (সাধারণত 80 for HTTP, 443 for HTTPS) এ বসে থাকে।

Request এলেই সেটা process শুরু করে।


৩ । **Processing:**

Static file হলে (HTML, CSS, Image) → সরাসরি পাঠিয়ে দেয়।

Dynamic file হলে (PHP, Node.js, Python) → server-side language/process চালিয়ে result তৈরি করে।

৪ । **Response Back:**

Web server সেই data কে browser-এর কাছে পাঠায়।

Browser সেটা render করে webpage আকারে দেখায়।




###  Web Server এর Example

১। Apache HTTP Server → সবচেয়ে পুরানো আর জনপ্রিয়।

২ । Nginx → lightweight, fast, reverse proxy হিসেবে ব্যবহৃত হয়।

৩ । LiteSpeed → খুবই fast, hosting providers বেশি ব্যবহার করে।

৪ । Microsoft IIS (Internet Information Services) → Windows server-এর জন্য।


**Static vs Dynamic Response**

- **Static Content:**
যেমন → HTML, CSS, JS, Images
(Server কোনো calculation করে না, সরাসরি পাঠিয়ে দেয়)

- **Dynamic Content:**
যেমন → PHP, Node.js, Python দিয়ে তৈরি data
(Server কোড execute করে, database থেকে data নিয়ে response পাঠায়)

**উদাহরণ (Flow)**

- আপনি Browser এ → facebook.com লিখলেন

- Browser request পাঠাল → Facebook-এর server-এ

- Web server (ধরি Nginx) request নিলো

- PHP / HackLang backend চালিয়ে database থেকে data নিলো

- Response তৈরি করে JSON/HTML আকারে browser-এ পাঠালো

- Browser সেটা render করে → তোমার timeline দেখালো

**সংক্ষেপে**

Web Server হলো “মধ্যবর্তী postman” →
যে আপনার Browser থেকে আসা চিঠি (request) নেয়, server-এর ভেতর থেকে উত্তর (response) বের করে আবার Browser-এ পৌঁছে দেয়।

---

###  ওয়েব সার্ভারের কাজ কি কি?

ওয়েব সার্ভার বিভিন্ন ধরনের কাজ করে। প্রধান কাজগুলো হলো:

* ব্রাউজার থেকে আসা HTTP/HTTPS রিকোয়েস্ট গ্রহণ করা।

* স্ট্যাটিক কন্টেন্ট (HTML, CSS, JS, Images) সরাসরি ব্রাউজারে সার্ভ করা।

* ডাইনামিক রিকোয়েস্ট প্রোসেস করার জন্য অ্যাপ্লিকেশন সার্ভারে রিকোয়েস্ট ফরওয়ার্ড করা।

* SSL/TLS হ্যান্ডশেকের মাধ্যমে নিরাপদ HTTPS সংযোগ প্রদান করা।

* লগিং এবং মনিটরিং করা।

* লোড ব্যালান্সিং এবং ক্যাশিং এর মাধ্যমে পারফরম্যান্স বৃদ্ধি করা।



<Webserver/>


---

###  ওয়েব সার্ভারের উদাহরণ

বিভিন্ন ধরনের ওয়েব সার্ভার আছে। সবচেয়ে পরিচিতগুলো হলো:

* Apache HTTP Server

* Nginx

* Microsoft IIS

* LiteSpeed

* Caddy

---

###  কোন ওয়েব সার্ভার কি করে?

* Apache: খুবই ফ্লেক্সিবল, .htaccess দিয়ে per-directory configuration সম্ভব, স্ট্যাটিক এবং ডাইনামিক উভয় ধরনের কন্টেন্ট হ্যান্ডেল করতে পারে।
* Nginx: হালকা ও দ্রুত, ইভেন্ট-ড্রিভেন আর্কিটেকচার, স্ট্যাটিক ফাইল সার্ভে এবং রিভার্স প্রোক্সি হিসেবে পারফরম্যান্স বেশি।
* Microsoft IIS: Windows server পরিবেশে ব্যবহৃত, সহজ GUI এর মাধ্যমে কনফিগার করা যায়।
* LiteSpeed: high performance, shared hosting environment এ জনপ্রিয়।
* Caddy: modern, HTTPS auto-configurable, ছোট এবং ব্যবহার সহজ।

---

###  অ্যাপ্লিকেশন সার্ভার কি?

অ্যাপ্লিকেশন সার্ভার হলো একটি সার্ভার যা আপনার বিজনেজ  লজিক এবং ডাইনামিক প্রোসেসিং সম্পাদন করে। এটি ডাটাবেস থেকে তথ্য নিয়ে প্রোসেস করে এবং ক্লায়েন্টকে রেসপন্স প্রদান করে।

---

###  অ্যাপ্লিকেশন সার্ভার কিভাবে কাজ করে?

অ্যাপ্লিকেশন সার্ভার মূলত রিকোয়েস্ট রিসিভ করে, ডাটাবেস বা অন্য সার্ভিস থেকে ডাটা নিয়ে প্রোসেস করে এবং রেসপন্স তৈরি করে। উদাহরণস্বরূপ, Express.js ব্যবহার করলে:

* ক্লায়েন্ট /api/users এ রিকোয়েস্ট পাঠালে Express.js route হ্যান্ডলার সেই রিকোয়েস্ট নেয়।
* ডাটাবেস থেকে ইউজার তথ্য নিয়ে JSON আকারে রেসপন্স প্রস্তুত করে।
* ক্লায়েন্টকে সেই ডাটা ফেরত পাঠায়।

---

###  এপিআই সার্ভার কি?

এপিআই সার্ভার হলো এমন একটি সার্ভার যা মূলত **ডেটা** প্রদান করে। এটি ইউজার ইন্টারফেস রেন্ডার করে না, বরং অ্যাপ্লিকেশন বা মোবাইল ক্লায়েন্টকে JSON/XML আকারে তথ্য সরবরাহ করে।

---

###  এপিআই সার্ভার কিভাবে কাজ করে?

* ক্লায়েন্ট কোনো API endpoint এ রিকোয়েস্ট পাঠায়।
* API সার্ভার রিকোয়েস্ট হ্যান্ডেল করে এবং প্রাসঙ্গিক ডেটা ডাটাবেস থেকে নিয়ে আসে।
* প্রোসেসিং শেষে JSON বা XML আকারে ডেটা রেসপন্স হিসেবে ক্লায়েন্টকে পাঠানো হয়।

---

###  ওয়েব সার্ভার এবং অ্যাপ্লিকেশন সার্ভারের মধ্যে পার্থক্য

* ওয়েব সার্ভার মূলত **স্ট্যাটিক কন্টেন্ট সার্ভ করা এবং রিভার্স প্রোক্সি হিসেবে কাজ করে**, অ্যাপ্লিকেশন সার্ভারের সঙ্গে যোগাযোগ করে।
* অ্যাপ্লিকেশন সার্ভার মূলত **ডাইনামিক কন্টেন্ট তৈরি এবং বিজনেজ  লজিক পরিচালনা** করে।
* সব API সার্ভার অ্যাপ্লিকেশন সার্ভারের অংশ হতে পারে, কিন্তু সব অ্যাপ্লিকেশন সার্ভার API সার্ভার নয়।

---

###  কেন আমাদের ওয়েব সার্ভার লাগবে?

Production environment এ অনেক ইউজার একসাথে রিকোয়েস্ট পাঠাবে। ওয়েব সার্ভার ব্যবহার করলে:

* স্ট্যাটিক ফাইল দ্রুত সার্ভ করা যায়।
* HTTPS এবং নিরাপত্তা বজায় রাখা যায়।
* লোড ব্যালান্সিং ও স্কেলিং সহজ হয়।
* ডাইনামিক রিকোয়েস্ট API/অ্যাপ্লিকেশন সার্ভারে পাঠানো হয়।

---

###  ওয়েব সার্ভার কিভাবে অ্যাপ্লিকেশন সার্ভারের সঙ্গে কমিউনিকেশন করে

* ওয়েব সার্ভার একটি **রিভার্স প্রোক্সি** হিসেবে কাজ করে।
* ক্লায়েন্টের রিকোয়েস্ট গ্রহণের পর প্রাসঙ্গিক রিকোয়েস্ট অ্যাপ্লিকেশন সার্ভারে ফরওয়ার্ড করে।
* অ্যাপ্লিকেশন সার্ভার প্রোসেস করে রেসপন্স ওয়েব সার্ভারের কাছে পাঠায়।
* ওয়েব সার্ভার রেসপন্স ব্রাউজারে পৌঁছে দেয়।

---

###  ওয়েব সার্ভারের কাজের ধাপ

1. ক্লায়েন্ট থেকে রিকোয়েস্ট গ্রহণ করা।
2. স্ট্যাটিক ফাইল থাকলে সরাসরি সার্ভ করা।
3. ডাইনামিক রিকোয়েস্ট হলে অ্যাপ্লিকেশন সার্ভারে ফরওয়ার্ড করা।
4. রেসপন্স ক্লায়েন্টে পাঠানো।
5. লগিং ও মনিটরিং।
6. HTTPS/SSL হ্যান্ডল করা।

---

###  বাস্তবে ওয়েব সার্ভার কিভাবে ব্যবহার হয়

Production environment এ ওয়েব সার্ভার সব রিকোয়েস্ট প্রথমে গ্রহণ করে, স্ট্যাটিক ফাইল সরাসরি সার্ভ করে এবং ডাইনামিক রিকোয়েস্ট অ্যাপ্লিকেশন সার্ভারে পাঠায়। এটি নিরাপদ, দ্রুত এবং স্কেলেবল হয়।

---
**বাস্তবিক উদাহরণ:**
 ধরুন আপনার একটা ওয়েবসাইট আছে:

-  Domain: **example.com**
-  Backend আপনি বানিয়েছেন **Express.js** দিয়ে
-  Database আছে **PostgreSQL**

এখন কীভাবে পুরো জিনিসটা user-এর browser পর্যন্ত যায়?

---

###   System Architecture Flow

### 1. User → Browser Request

* কেউ browser এ লিখলো → `https://example.com`
* Browser DNS এর মাধ্যমে **Server-এর IP** খুঁজে পেলো

---

### 2. Front-facing Web Server (Nginx/Apache)

* Browser এর request প্রথমে পৌঁছায় **Nginx/Apache** এর কাছে।
* এরা **"প্রধান দরোয়ান"** এর মতো কাজ করে:

  * SSL/TLS (HTTPS encryption) manage করে
  * Static file (HTML, CSS, JS, Images) সরাসরি serve করতে পারে
  * Load balancing করতে পারে (একাধিক Express.js instance এ request ভাগ করে দেয়)
  * Security features (rate limiting, firewall rules) handle করে

**উদাহরণ (Nginx config):**

```nginx
server {
    listen 80;
    server_name example.com;

    location / {
        proxy_pass http://localhost:3000; # Express server এ পাঠাচ্ছে
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }

    location /static/ {
        root /var/www/example.com; # Static files সরাসরি serve করছে
    }
}
```

---

### 3. Application Server (Express.js)

* এখন request চলে গেলো আপনার **Express.js app** এ → যেটা `localhost:3000` এ চলছে।
* Express.js এখানে **business logic** execute করবে:

  * কোন route এ কী হবে সেটা চেক করবে
  * যদি `/api/users` call হয় → database থেকে user data নিয়ে JSON return করবে
  * Middleware ব্যবহার করে authentication / validation করবে

**উদাহরণ (Express route):**

```js
app.get("/api/users", async (req, res) => {
  const users = await db.query("SELECT * FROM users");
  res.json(users.rows);
});
```

---

### 4. Database Layer

* Express.js database (PostgreSQL/MongoDB/MySQL) থেকে data নিয়ে আসে
* তারপর সেটা response আকারে ফেরত পাঠায়

---

### 5. Response Back

* Express.js → Response দিলো JSON/HTML আকারে
* Nginx সেটা Browser এর কাছে পাঠিয়ে দিলো
* Browser render করে ওয়েবসাইট দেখালো

---

##  এখানে Separation of Concern (কে কী করছে?)

| Component                           | কাজ                                                                                    |
| ----------------------------------- | -------------------------------------------------------------------------------------- |
| **Nginx/Apache (Web Server)**       | Request প্রথমে ধরে, static file serve করে, reverse proxy এর মাধ্যমে Express.js এ পাঠায় |
| **Express.js (Application Server)** | Application logic, API, authentication, database query, dynamic content handle করে     |
| **Database**                        | Data সংরক্ষণ ও রিটার্ন করে                                                             |

---

##  Diagram (Flow)

```
User Browser
     ↓
 [ Nginx / Apache ]  ←→  (Static files serve করে)
     ↓
 [ Express.js App ]  ←→  (Business logic, API, Authentication)
     ↓
 [ Database ]        ←→  (Data storage & queries)
```

---

তাই, বাস্তবে Nginx/Apache কে রাখা হয় **gatekeeper/front door** এর মতো, আর Express.js কে রাখা হয় **ঘরের ভেতরে বসে থাকা প্রোগ্রামার** এর মতো — যে আসল কাজ (logic, data fetch, API) করে দেয়।


---

```
Client Browser
     ↓
 [Web Server: Nginx/Apache] 
     ├─ Static Files → সরাসরি সার্ভ
     └─ Dynamic Request → Application Server (Express.js)
                            ↓
                        Database
```

---


##  Static File মানে কী?

**Static file** হলো এমন ফাইল যেগুলো সার্ভার কোনো computation/logic না চালিয়ে, **সরাসরি ব্রাউজারে পাঠিয়ে দিতে পারে**।
যেমন:

* `index.html`
* `style.css`
* `app.js` (frontend js)
* Images (jpg, png, svg)
* Fonts

---

## Static File কোথায় থাকে?

এটা **আপনি কীভাবে project structure করলেন তার উপর নির্ভর করে**।

###  যদি আপনি শুধু Node.js + Express ব্যবহার করেন

তাহলে সাধারণত project structure হয় এরকম:

```
my-app/
 ├── public/        ← static ফাইল রাখার জায়গা
 │    ├── index.html
 │    ├── style.css
 │    └── logo.png
 ├── src/
 │    └── server.js
 └── package.json
```

Express.js config:

```js
app.use(express.static("public"));
```

 এখানে Express `/public` ফোল্ডার থেকে static file serve করবে।

* `/index.html` → `http://localhost:3000/index.html`
* `/logo.png` → `http://localhost:3000/logo.png`

---

###  যদি আপনি Production এ Nginx ব্যবহার করেন

ধরেন আপনি React/Next.js build করছেন → `out/` বা `dist/` বা `build/` ফোল্ডার তৈরি হয়েছে।
এগুলো pure static ফাইল।

Structure:

```
/var/www/example.com/
 ├── index.html
 ├── style.css
 ├── bundle.js
 └── image.png
```

Nginx config:

```nginx
server {
    listen 80;
    server_name example.com;

    root /var/www/example.com;
    index index.html;

    location / {
        try_files $uri $uri/ =404;
    }
}
```

এখানে Nginx সরাসরি `/var/www/example.com` ফোল্ডার থেকে static file দেবে।
Express.js এর কাছে পাঠানোর দরকারই হবে না।

---

## কেন Express এর static serve production এ কম ব্যবহার করা হয়?

* Express static serve করতে পারে ঠিকই, কিন্তু **Nginx অনেক দ্রুত serve করে** (C-তে লেখা highly optimized server)।
* তাই সাধারণত:

  * **Static file** → সরাসরি Nginx serve করে
  * **Dynamic API request** → Nginx proxy\_pass করে Express.js এ পাঠায়

---

##  Example Flow (Production এ)

```
Browser request → Nginx
   ├── /style.css  → সরাসরি Nginx থেকে ফাইল দেবে
   ├── /logo.png   → সরাসরি Nginx থেকে ফাইল দেবে
   └── /api/users  → proxy করে Express.js app এ পাঠাবে
```

---

তাই  Node.js app এ যদি `public/` ফোল্ডারে static file থাকে, সেটা আপনি চাইলে Express দিয়েও serve করতে পারেন,
কিন্তু production এ সাধারণত **static ফাইল আলাদা build ফোল্ডারে রেখে Nginx দিয়ে serve করা হয়**।



##  Localhost এ Nginx/Apache কেন লাগে না, কিন্তু Production এ লাগে

Localhost এ শুধু একটি ইউজার থাকে। Node.js নিজেই HTTP সার্ভার চালাতে পারে।
Production এ অনেক ইউজার একসাথে আসলে, ওয়েব সার্ভার দরকার হয় নিরাপত্তা, পারফরম্যান্স, লোড ব্যালান্সিং এবং HTTPS ব্যবস্থাপনার জন্য।


###  Localhost এ কেন Nginx/Apache লাগে না?

 Localhost এ আপনি সাধারণত নিজের কম্পিউটারে ডেভেলপ করছেন,

* আপনি সরাসরি `Express.js (Node.js)` চালাচ্ছেন → `app.listen(3000)`
* Browser → `http://localhost:3000`
* Request/Response চলে আসছে → কাজ শেষ 

এখানে **একজনই ইউজার ** → তাই জটিলতা নেই।
আপনার Node.js server-ই static file + API serve করে দিচ্ছে।

---

##  কিন্তু Production এ কেন দরকার?

Production মানে  **বাস্তবে অনেক user একসাথে তোমার server-এ request করবে**।
এই জায়গায় সমস্যা হয়:

### 1. **Performance Issue**

* Node.js Express static ফাইল serve করতে পারে, কিন্তু Nginx/Apache অনেক দ্রুত serve করে।
* কারণ Nginx C তে লেখা, multi-threaded, memory কম খায়।
* তাই static file serve করার responsibility Node.js এর উপর না দিয়ে Nginx এর উপর দিই।

---

### 2. **Security Issue**

* Production server-এ HTTPS (SSL/TLS) certificate দরকার।
* এই encryption handle করার জন্য Nginx/Apache অনেক ভালো।
* সরাসরি Node.js এ HTTPS চালানো সম্ভব, কিন্তু secure, scalable না।

---

### 3. **Load Balancing & Scaling**

* ধরেন 10,000 user একসাথে তোমার সাইটে ঢুকলো।
* Express.js একা এত load হ্যান্ডেল করতে পারবে না।
* Nginx/Apache → load balancing করতে পারে (একাধিক Node.js instance এ request ভাগ করে দেবে)।

---

### 4. **Reverse Proxy Advantage**

* Nginx/Apache → reverse proxy হিসেবে কাজ করে।
* মানে User কখনও আসল Express.js server এর port (3000) দেখতে পাবে না।
* তারা শুধু `https://example.com` দেখবে।
* এর ফলে নিরাপত্তা + flexibility বাড়ে।

---

###  উদাহরণ

Localhost এ:

```
Browser → http://localhost:3000 → Express.js → Response
```

Production এ:

```
Browser → https://example.com → Nginx/Apache (front door)
                           ├── Static file (HTML, CSS, JS) serve করে দেয়
                           └── Dynamic request proxy করে Express.js এ পাঠায়
                                            ↓
                                       Database থেকে data নিয়ে আসে
```

---

## সহজভাবে analogy (উদাহরণ)

* **Localhost:**
  আপনি একা ঘরে আছেন → দরজা খোলা → সরাসরি বন্ধুকে ঢুকতে দিচ্ছেন

* **Production:**
  আপনি একটা বড় অফিসে বসে আছেন → শত শত লোক একসাথে আসছে → দরোয়ান (Nginx/Apache) দরজায় বসে চেক করছে কে আসবে, কে কোথায় যাবে।

  * Static paper/documents (CSS, JS, Images) দরোয়ান সরাসরি দিয়ে দিচ্ছে।
  * কিন্তু জটিল প্রশ্ন (API call) হলে আপনার কাছে পাঠাচ্ছে (Express.js)।

---

তাই **localhost এ দরোয়ান লাগছে না**, কারণ ভিড় নেই।
কিন্তু **production এ দরোয়ান (Nginx/Apache) বসাতে হয়**, যাতে performance + security + scaling maintain হয়।

---

## Application deploy করতে ওয়েব সার্ভার বাধ্যতামূলক কি?

* ছোট প্রোজেক্ট বা ডেভেলপমেন্টে Node.js/Express নিজেই HTTP সার্ভার চালিয়ে deploy করা যায়।
* Production এ ওয়েব সার্ভার ব্যবহার করলে সুবিধা বেশি, তাই তা strongly recommended।

---

###  Short Answer

**না, আপনার application deploy করতে web server (Nginx/Apache) একেবারেই বাধ্যতামূলক না।**
Express.js (বা যেকোনো framework) নিজেই http server চালাতে পারে, তাই সরাসরি deploy করা সম্ভব।

কিন্তু…
**Production এ আমরা সাধারণত web server ব্যবহার করি, কারণ এতে অনেক সুবিধা মেলে।**

---

###  Web Server ছাড়া Deploy করা

* আপনি সরাসরি **Node.js server (Express app)** চালাতে পারেন:

```bash
node server.js
```

* তখন আপনার অ্যাপ `http://your-server-ip:3000` এ accessible হবে।
* SSL/TLS (https) চাইলে আপনি সরাসরি Node.js এ certificate bind করতে পারেন। 
* ছোট প্রোজেক্ট বা dev/test environment এ এটা একদম ঠিক আছে।

---

##  Web Server সহ Deploy করা

Production এ সাধারণত **Nginx বা Apache** ব্যবহার করা হয়, কারণ:

1. **Performance** → Static files serve করতে super fast
2. **Security** → SSL/TLS (HTTPS), firewall rules, DDoS protection handle করতে পারে
3. **Reverse Proxy** → User কখনো `:3000` দেখবে না, তারা শুধু domain দেখবে
4. **Load Balancing** → একাধিক Node.js instance এর মধ্যে load ভাগ করে
5. **Process Management** → Crashes হলে Nginx বেঁচে থাকে, আর backend restart করে দিতে পারে

---

###  উদাহরণ: Without Web Server

```
User Browser → http://your-ip:3000 → Node.js (Express app)
```

### উদাহরণ: With Web Server

```
User Browser → https://yourdomain.com → [Nginx]
                                 ├── Static file serve করে
                                 └── API request proxy করে Express app এ পাঠায়
```

---

### Best Practice

* **ছোট personal project / demo** → শুধু Express app চালালেই চলবে।
* **Production / অনেক user / public site** → Web server (Nginx/Apache) ব্যবহার করা strongly recommended।

---

তাই  **deploy করতে Web Server লাগবেই – এমন কোনো নিয়ম নেই**।
তবে যদি আপনার app শুধু personal use/test এর জন্য হয় → সরাসরি Node.js চালালেই হবে।
কিন্তু যদি public site/production এ চালান → Web server দিলে অনেক বেশি secure, fast আর stable হবে।

---


##  ওয়েব সার্ভার কিভাবে setup করতে হয় (Nginx + Apache)

### Nginx:

1. Nginx install করা।
2. Node.js অ্যাপ চালু রাখা (PM2 দিয়ে)।
3. Nginx config দিয়ে reverse proxy তৈরি করা।
4. Optional: Certbot দিয়ে SSL।

---

###  1. আপনার Application Server রেডি করেন

ধরি আপনার Node.js app `/var/www/myapp` এ আছে।
`server.js` ফাইল আছে যেটা 3000 port এ চলে।

```bash
cd /var/www/myapp
npm install
node server.js   # test করার জন্য
```

এখন Browser → `http://your-server-ip:3000` দিলে app কাজ করবে।

---

###  2. PM2 দিয়ে Process Manager চালান

Production এ `node server.js` চালানো safe না (crash হলে বন্ধ হয়ে যাবে)।
PM2 ব্যবহার করেন :

```bash
npm install -g pm2
pm2 start server.js --name myapp
pm2 startup
pm2 save
```

এতে সার্ভার reboot হলেও app auto start হবে।

---

### 3. Nginx Install করেন

Ubuntu/Debian এ:

```bash
sudo apt update
sudo apt install nginx -y
```

Check:

```bash
systemctl status nginx
```

---

### 4. Nginx Configuration (Reverse Proxy)

নতুন config ফাইল বানান:

```bash
sudo nano /etc/nginx/sites-available/myapp
```

এখানে লেখেন:

```nginx
server {
    listen 80;
    server_name example.com www.example.com;

    location / {
        proxy_pass http://localhost:3000;   # আপনার Node.js app port
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }

    location /static/ {
        root /var/www/myapp/public; # চাইলে static file serve করতে পারেন
    }
}
```

এখন ফাইল enable করেন:

```bash
sudo ln -s /etc/nginx/sites-available/myapp /etc/nginx/sites-enabled/
sudo nginx -t   # config test
sudo systemctl restart nginx
```

---

### 5. (Optional) SSL Setup (HTTPS এর জন্য)

Free SSL এর জন্য **Certbot** ব্যবহার করতে পারেন:

```bash
sudo apt install certbot python3-certbot-nginx -y
sudo certbot --nginx -d example.com -d www.example.com
```

এখন আপনার site হবে `https://example.com` 🎉

---

###  Final Flow

```
Browser → https://example.com
         ↓
   [Nginx Web Server]
         ├── /static/* → সরাসরি static files serve করছে
         └── Other request → proxy_pass → Express.js (PM2 managed)
                                   ↓
                              Database (MongoDB/Postgres/MySQL)
```

---

###  Summary

* Node.js app 3000 port এ run করছে (PM2 দিয়ে manage করা হচ্ছে)
* Nginx 80/443 port এ listen করছে → User এর সব request আগে Nginx এ যায়
* Nginx static files serve করছে + dynamic request Express app এ পাঠাচ্ছে
* HTTPS এর জন্য Certbot দিয়ে SSL install করা যায়

---


### PM2 (Process Manager 2) **Node.js process manager**

PM2-এর কাজ হলো:

* আপনার Node.js / Express / NestJS / Next.js server background-এ চালু রাখা।
* Server crash করলে আবার automatically চালু করা।
* একাধিক instance cluster mode-এ চালাতে পারা।
* Logs maintain করা।
* Monitoring ও dashboard দেওয়া।

উদাহরণ:
ধরেন আপনি `node server.js` দিয়ে সার্ভার চালান। SSH বন্ধ করলে বা server crash করলে অ্যাপ বন্ধ হয়ে যাবে।
কিন্তু `pm2 start server.js` দিলে সেটা background-এ চলতে থাকবে, সার্ভার down হলে আবার চালু হবে।

AWS-এ deploy করলে আপনি চাইলে **PM2** use করতে পারো তোমার Node.js application manage করার জন্য।
মানে AWS শুধু server দেবে, কিন্তু process manage করার জন্য আপনি PM2 ব্যবহার করবে।

সংক্ষেপে:

* PM2 = Node.js process manager
* AWS = Cloud provider

আপনি চাইলে **AWS + PM2** একসাথে use করতে পারবেন production-এ।


#### Apache:

1. Apache install করা।
2. proxy modules enable করা।
3. VirtualHost config তৈরি করা reverse proxy হিসেবে।
4. Optional: SSL setup করা।


---

###  1. আপনার Application Server রেডি করেন

ধরি আপনার Node.js (Express) app `/var/www/myapp` ফোল্ডারে আছে।
সাধারণত port `3000` এ run করবে।

```bash
cd /var/www/myapp
npm install
node server.js   # test করার জন্য চালান 
```

এখন browser এ → `http://your-server-ip:3000` দিলে কাজ করবে।

---

### 2. PM2 দিয়ে manage করেন 

Production এ app crash হলে যেন বন্ধ না হয়ে যায়, তাই **PM2** ব্যবহার করেন :

```bash
npm install -g pm2
pm2 start server.js --name myapp
pm2 startup
pm2 save
```

---

###  3. Apache Install করেন 

Ubuntu/Debian এ:

```bash
sudo apt update
sudo apt install apache2 -y
```

Check:

```bash
systemctl status apache2
```

---

###  4. Apache Module Enable করেন 

Apache কে reverse proxy হিসেবে চালানোর জন্য নিচের modules enable করতে হবে:

```bash
sudo a2enmod proxy
sudo a2enmod proxy_http
sudo a2enmod headers
```

Restart Apache:

```bash
sudo systemctl restart apache2
```

---

###  5. Virtual Host Config করেন 

Apache config ফাইল `/etc/apache2/sites-available/myapp.conf` করেন :

```apache
<VirtualHost *:80>
    ServerName example.com
    ServerAlias www.example.com

    ProxyPreserveHost On
    ProxyRequests Off
    ProxyPass / http://localhost:3000/
    ProxyPassReverse / http://localhost:3000/

    ErrorLog ${APACHE_LOG_DIR}/myapp_error.log
    CustomLog ${APACHE_LOG_DIR}/myapp_access.log combined
</VirtualHost>
```

---

###  6. Config Enable করেন 

```bash
sudo a2ensite myapp.conf
sudo systemctl reload apache2
```

---

###  7. (Optional) SSL Setup (HTTPS এর জন্য)

Apache এর জন্য certbot install করেন :

```bash
sudo apt install certbot python3-certbot-apache -y
sudo certbot --apache -d example.com -d www.example.com
```

এখন তোমার site হবে `https://example.com` 🎉

---

###  Final Flow

```
Browser → https://example.com
         ↓
 [ Apache Web Server ]
         ↓
 ProxyPass → Express.js app (localhost:3000, PM2 দিয়ে run হচ্ছে)
         ↓
   Database (MongoDB / PostgreSQL / MySQL)
```

---

###  Summary

* Apache এখানে **reverse proxy** হিসেবে কাজ করছে
* Express.js আসল backend app handle করছে
* Apache SSL, logging, static file serve করা ইত্যাদি manage করতে পারে
* SSL চাইলে `certbot --apache` ব্যবহার করতে পারো


---

###  Apache এবং Nginx এর মধ্যে পার্থক্য ও ব্যবহার

* Apache বেশি ফ্লেক্সিবল, legacy system-এ বেশি। .htaccess দিয়ে per-directory config সম্ভব।
* Nginx হালকা, event-driven, স্ট্যাটিক ফাইল দ্রুত সার্ভ করে।
* বর্তমান প্রফেশনাল এবং high-performance production environment-এ Nginx বেশি ব্যবহার হয়।
* Apache এখনও বহু shared hosting environment-এ জনপ্রিয়।

---


