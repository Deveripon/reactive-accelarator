## Design Principle ‡¶ï‡¶ø? 

**Design Principles** ‡¶Æ‡¶æ‡¶®‡ßá ‡¶π‡¶≤‡ßã ‚Äî ‡¶è‡¶Æ‡¶® ‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶Æ‡ßå‡¶≤‡¶ø‡¶ï guideline ‡¶Ø‡ßá‡¶ó‡ßÅ‡¶≤‡ßã ‡¶Æ‡ßá‡¶®‡ßá ‡¶ö‡¶≤‡¶≤‡ßá ‡¶ï‡ßã‡¶° clean, scalable, testable ‡¶Ü‡¶∞ maintainable ‡¶π‡ßü‡•§

‡¶è‡¶ó‡ßÅ‡¶≤‡ßã‡¶ï‡ßá ‡¶Ö‡¶®‡ßá‡¶ï ‡¶∏‡¶Æ‡ßü **foundation of design patterns** ‡¶ì ‡¶¨‡¶≤‡¶æ ‡¶π‡ßü, ‡¶ï‡¶æ‡¶∞‡¶£ design patterns ‡¶è‡¶á principles ‡¶è‡¶∞ ‡¶â‡¶™‡¶∞ ‡¶¶‡¶æ‡¶Å‡ßú‡¶ø‡ßü‡ßá ‡¶§‡ßà‡¶∞‡¶ø‡•§

---

## üîπ Key Design Principles (Backend/Software Development ‡¶è)

### 1. **SOLID Principles**

üëâ Object-Oriented design ‡¶è‡¶∞ ‡¶∏‡¶¨‡¶ö‡ßá‡ßü‡ßá ‡¶ú‡¶®‡¶™‡ßç‡¶∞‡¶ø‡ßü principle set‡•§

1. **S - Single Responsibility Principle (SRP)**

   * ‡¶è‡¶ï‡ßá‡¶ï‡¶ü‡¶æ class/module ‡¶è‡¶∞ **‡¶è‡¶ï‡¶ü‡¶æ‡¶á ‡¶ï‡¶æ‡¶ú** ‡¶•‡¶æ‡¶ï‡¶¨‡ßá‡•§
   * Example: `UserService` ‡¶∂‡ßÅ‡¶ß‡ßÅ user-related business logic handle ‡¶ï‡¶∞‡¶¨‡ßá, payment logic ‡¶®‡¶æ‡•§

2. **O - Open/Closed Principle (OCP)**

   * Code **extension ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø open**, ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ **modification ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø closed** ‡¶π‡¶¨‡ßá‡•§
   * Example: ‡¶®‡¶§‡ßÅ‡¶® payment gateway add ‡¶ï‡¶∞‡¶§‡ßá ‡¶ö‡¶æ‡¶á‡¶≤‡ßá ‡¶®‡¶§‡ßÅ‡¶® class add ‡¶ï‡¶∞‡¶¨‡ßã, existing ‡¶ï‡ßã‡¶° modify ‡¶ï‡¶∞‡¶¨‡ßã ‡¶®‡¶æ‡•§

3. **L - Liskov Substitution Principle (LSP)**

   * Parent class ‡¶è‡¶∞ ‡¶ú‡¶æ‡ßü‡¶ó‡¶æ‡ßü Child class use ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶¨‡ßá, behavior ‡¶®‡¶∑‡ßç‡¶ü ‡¶π‡¶¨‡ßá ‡¶®‡¶æ‡•§
   * Example: `PaymentStrategy` interface ‚Üí Stripe/Paypal/Bkash ‡¶∏‡¶¨ ‡¶ú‡¶æ‡ßü‡¶ó‡¶æ‡ßü interchange ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶¨‡ßá‡•§

4. **I - Interface Segregation Principle (ISP)**

   * ‡¶¨‡¶°‡¶º ‡¶è‡¶ï‡¶ü‡¶æ interface ‡¶è‡¶∞ ‡¶¨‡¶¶‡¶≤‡ßá ‡¶õ‡ßã‡¶ü ‡¶õ‡ßã‡¶ü interface ‡¶¨‡¶æ‡¶®‡¶æ‡¶ì‡•§
   * Example: `IReadable`, `IWritable` ‡¶Ü‡¶≤‡¶æ‡¶¶‡¶æ, ‡¶Ø‡¶æ‡¶§‡ßá class ‡¶ó‡ßÅ‡¶≤‡ßã only ‡¶™‡ßç‡¶∞‡ßü‡ßã‡¶ú‡¶®‡ßÄ‡ßü method implement ‡¶ï‡¶∞‡ßá‡•§

5. **D - Dependency Inversion Principle (DIP)**

   * High-level module, low-level ‡¶è‡¶∞ ‡¶â‡¶™‡¶∞ depend ‡¶ï‡¶∞‡¶¨‡ßá ‡¶®‡¶æ ‚Üí ‡¶¶‡ßÅ‡¶ú‡¶®‡ßá‡¶á depend ‡¶ï‡¶∞‡¶¨‡ßá abstraction ‡¶è‡¶∞ ‡¶â‡¶™‡¶∞‡•§
   * Example: `BookingService` ‚Üí `PaymentStrategy` interface use ‡¶ï‡¶∞‡¶¨‡ßá, ‡¶®‡¶ø‡¶∞‡ßç‡¶¶‡¶ø‡¶∑‡ßç‡¶ü Stripe class ‡¶®‡¶æ‡•§

---

### 2. **DRY (Don‚Äôt Repeat Yourself)**

üëâ Duplicate code ‡¶®‡¶æ ‡¶≤‡¶ø‡¶ñ‡ßá reusable function/service ‡¶¨‡¶æ‡¶®‡¶æ‡¶§‡ßá ‡¶π‡¶¨‡ßá‡•§
Example: JWT verify logic ‡¶Ü‡¶≤‡¶æ‡¶¶‡¶æ `AuthService` ‡¶è ‡¶∞‡¶æ‡¶ñ‡¶æ ‚Üí controller ‡¶ó‡ßÅ‡¶≤‡ßã ‡¶¨‡¶æ‡¶∞‡¶¨‡¶æ‡¶∞ ‡¶≤‡¶ø‡¶ñ‡¶¨‡ßá ‡¶®‡¶æ‡•§

---

### 3. **KISS (Keep It Simple, Stupid)**

üëâ ‡¶ú‡¶ü‡¶ø‡¶≤ ‡¶ï‡¶∞‡ßá ‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶¨‡¶æ‡¶®‡¶æ‡¶¨‡ßá ‡¶®‡¶æ, ‡¶Ø‡¶§‡¶ü‡¶æ possible simple ‡¶∞‡¶æ‡¶ñ‡ßã‡•§
Example: CRUD API ‡¶¨‡¶æ‡¶®‡¶æ‡¶§‡ßá ‡¶ó‡¶ø‡ßü‡ßá unnecessary complex inheritance avoid ‡¶ï‡¶∞‡¶æ‡•§

---

### 4. **YAGNI (You Aren‚Äôt Gonna Need It)**

üëâ Future-proofing ‡¶è‡¶∞ ‡¶®‡¶æ‡¶Æ‡ßá ‡¶Ö‡¶™‡ßç‡¶∞‡ßü‡ßã‡¶ú‡¶®‡ßÄ‡ßü feature ‡¶≤‡¶ø‡¶ñ‡¶¨‡ßá ‡¶®‡¶æ‡•§
Example: User API ‡¶§‡ßá ‡¶Ü‡¶ó‡ßá ‡¶•‡ßá‡¶ï‡ßá ‚Äúmulti-role-permission-tree‚Äù ‡¶¨‡¶æ‡¶®‡¶æ‡¶®‡ßã‡¶∞ ‡¶¶‡¶∞‡¶ï‡¶æ‡¶∞ ‡¶®‡¶æ‡¶á, simple role ‡¶¶‡¶ø‡ßü‡ßá ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶ï‡¶∞‡ßã‡•§

---

### 5. **Separation of Concerns (SoC)**

üëâ ‡¶Ü‡¶≤‡¶æ‡¶¶‡¶æ ‡¶Ü‡¶≤‡¶æ‡¶¶‡¶æ ‡¶ï‡¶æ‡¶ú (concern) ‡¶Ü‡¶≤‡¶æ‡¶¶‡¶æ module ‡¶è ‡¶∞‡¶æ‡¶ñ‡ßã‡•§
Example: Controller ‚Üí ‡¶∂‡ßÅ‡¶ß‡ßÅ HTTP request handle ‡¶ï‡¶∞‡¶¨‡ßá, Service ‚Üí business logic, Repository ‚Üí database query‡•§

---

### 6. **Encapsulation**

üëâ Data hide ‡¶ï‡¶∞‡ßá ‡¶∂‡ßÅ‡¶ß‡ßÅ ‡¶¶‡¶∞‡¶ï‡¶æ‡¶∞‡¶ø method expose ‡¶ï‡¶∞‡ßã‡•§
Example: User entity ‚Üí password field private ‡¶•‡¶æ‡¶ï‡¶¨‡ßá, ‡¶∂‡ßÅ‡¶ß‡ßÅ hash/check method ‡¶•‡¶æ‡¶ï‡¶¨‡ßá‡•§

---

### 7. **Composition Over Inheritance**

üëâ Inheritance ‡¶è‡¶∞ ‡¶ö‡ßá‡ßü‡ßá composition use ‡¶ï‡¶∞‡ßã, ‡¶ï‡¶æ‡¶∞‡¶£ flexibility ‡¶¨‡ßá‡¶∂‡¶ø‡•§
Example: `NotificationService` ‡¶è‡¶∞ ‡¶≠‡ßá‡¶§‡¶∞‡ßá Email/SMS ‡¶ï‡ßç‡¶≤‡¶æ‡¶∏ inject ‡¶ï‡¶∞‡¶æ ‚Üí ‡¶Ü‡¶≤‡¶æ‡¶¶‡¶æ inheritance tree ‡¶¨‡¶æ‡¶®‡¶æ‡¶®‡ßã‡¶∞ ‡¶¶‡¶∞‡¶ï‡¶æ‡¶∞ ‡¶®‡ßá‡¶á‡•§

---

### 8. **Design for Change (Flexibility)**

üëâ System ‡¶è‡¶Æ‡¶®‡¶≠‡¶æ‡¶¨‡ßá design ‡¶ï‡¶∞‡ßã ‡¶Ø‡¶æ‡¶§‡ßá ‡¶∏‡¶π‡¶ú‡ßá extend/modify ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡ßü‡•§
Example: Microservice architecture ‡¶è ‡¶®‡¶§‡ßÅ‡¶® service add ‡¶ï‡¶∞‡¶≤‡ßá ‡¶Ö‡¶®‡ßç‡¶Ø‡¶ó‡ßÅ‡¶≤‡ßã break ‡¶®‡¶æ ‡¶π‡ßü‡•§

---

### 9. **Principle of Least Knowledge (Law of Demeter)**

üëâ Objects ‡¶è‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶ï‡¶Æ interaction ‡¶∞‡¶æ‡¶ñ‡ßã‡•§ One object should not know too much about another.
Example: Controller ‚Üí Service ‡¶ï‡ßá call ‡¶ï‡¶∞‡¶¨‡ßá, ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ service ‡¶è‡¶∞ internal repository ‡¶ï‡ßá directly ‡¶ú‡¶æ‡¶®‡¶¨‡ßá ‡¶®‡¶æ‡•§

---

### 10. **Fail Fast**

üëâ Error early detect ‡¶ï‡¶∞‡ßã‡•§
Example: API ‡¶§‡ßá validation middleware ‡¶∞‡¶æ‡¶ñ‡ßã, ‡¶Ø‡ßá‡¶® invalid data ‡¶Ü‡¶∏‡¶≤‡ßá ‡¶∂‡ßÅ‡¶∞‡ßÅ‡¶§‡ßá‡¶á reject ‡¶π‡ßü‡•§

---

## ‚úÖ Summary

‡¶∏‡¶¨‡¶ö‡ßá‡ßü‡ßá ‡¶ó‡ßÅ‡¶∞‡ßÅ‡¶§‡ßç‡¶¨‡¶™‡ßÇ‡¶∞‡ßç‡¶£ principles:

* **SOLID** ‚Üí maintainable OOP design
* **DRY** ‚Üí ‡¶ï‡ßã‡¶° duplication ‡¶ï‡¶Æ‡¶æ‡¶®‡ßã
* **KISS & YAGNI** ‚Üí simple ‡¶è‡¶¨‡¶Ç ‡¶™‡ßç‡¶∞‡ßü‡ßã‡¶ú‡¶®‡¶Æ‡¶§‡ßã design
* **SoC & Encapsulation** ‚Üí code separation ‡¶è‡¶¨‡¶Ç ‡¶®‡¶ø‡¶∞‡¶æ‡¶™‡¶¶ data handling
* **Composition over Inheritance** ‚Üí flexible design

---


---

## 1. **Single Responsibility Principle (SRP)**

> ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø class/module ‡¶è‡¶∞ ‡¶è‡¶ï‡¶ü‡¶æ‡¶á ‡¶ï‡¶æ‡¶ú ‡¶•‡¶æ‡¶ï‡¶¨‡ßá‡•§

```ts
// user.service.ts
@Injectable()
export class UserService {
  constructor(private userRepository: UserRepository) {}

  async createUser(dto: CreateUserDto) {
    return this.userRepository.create(dto);  // ‡¶∂‡ßÅ‡¶ß‡ßÅ user related logic
  }

  async getUser(id: number) {
    return this.userRepository.findById(id);
  }
}

// ‡¶Ö‡¶®‡ßç‡¶Ø file ‡¶è payment logic ‡¶•‡¶æ‡¶ï‡¶¨‡ßá PaymentService ‡¶è
```

**Benefit:**
Code clean ‡¶•‡¶æ‡¶ï‡ßá, ‡¶è‡¶ï ‡¶ú‡¶æ‡ßü‡¶ó‡¶æ‡ßü ‡¶∂‡ßÅ‡¶ß‡ßÅ ‡¶è‡¶ï‡¶ü‡¶æ responsibility handle ‡¶π‡ßü‡•§

---

## 2. **Open/Closed Principle (OCP)**

> Code extend ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø open, modify ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø closed‡•§

```ts
// payment.strategy.ts
interface PaymentStrategy {
  pay(amount: number): string;
}

class StripePayment implements PaymentStrategy {
  pay(amount: number) { return `Paid ${amount} via Stripe`; }
}

class PaypalPayment implements PaymentStrategy {
  pay(amount: number) { return `Paid ${amount} via Paypal`; }
}

// new gateway add ‡¶ï‡¶∞‡¶§‡ßá ‡¶π‡¶¨‡ßá ‚Üí ‡¶®‡¶§‡ßÅ‡¶® class add ‡¶ï‡¶∞‡¶≤‡ßá‡¶á ‡¶π‡¶¨‡ßá, existing class change ‡¶≤‡¶æ‡¶ó‡¶¨‡ßá ‡¶®‡¶æ
```

---

## 3. **Liskov Substitution Principle (LSP)**

> Parent ‡¶è‡¶∞ ‡¶ú‡¶æ‡ßü‡¶ó‡¶æ‡ßü child use ‡¶ï‡¶∞‡¶≤‡ßá‡¶ì system ‡¶†‡¶ø‡¶ï‡¶†‡¶æ‡¶ï ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡¶¨‡ßá‡•§

```ts
const payment: PaymentStrategy = new StripePayment();
console.log(payment.pay(100)); // ‡¶è‡¶ñ‡¶® PaypalPayment ‡¶¶‡¶ø‡ßü‡ßá replace ‡¶ï‡¶∞‡¶≤‡ßá‡¶ì ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡¶¨‡ßá
```

---

## 4. **Interface Segregation Principle (ISP)**

> ‡¶¨‡¶°‡¶º interface ‡¶®‡¶æ, ‡¶õ‡ßã‡¶ü ‡¶õ‡ßã‡¶ü interface ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßã‡•§

```ts
interface IReadable {
  read(id: number): any;
}

interface IWritable {
  create(data: any): any;
}

// BookRepository ‡¶∂‡ßÅ‡¶ß‡ßÅ read ‡¶ï‡¶∞‡¶¨‡ßá, CreateRepository ‡¶∂‡ßÅ‡¶ß‡ßÅ write ‡¶ï‡¶∞‡¶¨‡ßá
```

---

## 5. **Dependency Inversion Principle (DIP)**

> High-level modules low-level ‡¶è‡¶∞ ‡¶â‡¶™‡¶∞ depend ‡¶ï‡¶∞‡¶¨‡ßá ‡¶®‡¶æ, abstraction ‡¶è‡¶∞ ‡¶â‡¶™‡¶∞ depend ‡¶ï‡¶∞‡¶¨‡ßá‡•§

```ts
@Injectable()
class BookingService {
  constructor(private paymentStrategy: PaymentStrategy) {} // abstraction ‡¶è‡¶∞ ‡¶â‡¶™‡¶∞ depend
}

const stripePayment = new StripePayment();
const bookingService = new BookingService(stripePayment);
```

---

## 6. **DRY (Don‚Äôt Repeat Yourself)**

```ts
// auth.service.ts
@Injectable()
export class AuthService {
  validateToken(token: string) {
    // JWT validate logic
  }
}

// controller ‡¶ó‡ßÅ‡¶≤‡ßã ‡¶∂‡ßÅ‡¶ß‡ßÅ AuthService ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶¨‡ßá, ‡¶¨‡¶æ‡¶∞‡¶¨‡¶æ‡¶∞ JWT logic ‡¶≤‡¶ø‡¶ñ‡¶¨‡ßá ‡¶®‡¶æ
```

---

## 7. **KISS (Keep It Simple, Stupid)**

```ts
// Instead of complex nested if-else, use simple strategy pattern
const strategy = PaymentFactory.create(method);
strategy.pay(amount);
```

---

## 8. **YAGNI (You Aren‚Äôt Gonna Need It)**

```ts
// Avoid writing multi-role permission system before it's actually required
// Start with simple 'user' & 'admin' roles
```

---

## 9. **Separation of Concerns (SoC)**

```ts
// controller ‚Üí request/response
// service ‚Üí business logic
// repository ‚Üí DB query
```

Example:

```ts
// booking.controller.ts
@Post()
bookTrip(@Body() dto: BookingDto) {
  return this.bookingService.createBooking(dto);
}
```

---

## 10. **Encapsulation**

```ts
class UserEntity {
  private password: string;

  setPassword(pw: string) {
    this.password = hash(pw);
  }

  checkPassword(pw: string) {
    return compareHash(pw, this.password);
  }
}
```

---

## 11. **Composition Over Inheritance**

```ts
class EmailService { send(email: string) {} }
class SMSService { send(sms: string) {} }

class NotificationService {
  constructor(private email: EmailService, private sms: SMSService) {}

  notifyUser(user, message) {
    this.email.send(message);
    this.sms.send(message);
  }
}
```

---

## 12. **Principle of Least Knowledge (Law of Demeter)**

```ts
// Controller calls Service, Service calls Repository
// Controller never knows how repository works internally
const user = await userService.getUser(id); // Controller only interacts with service
```

---

## 13. **Fail Fast**

```ts
// DTO validation
@Post()
createUser(@Body() dto: CreateUserDto) {
  // class-validator automatically throws error if data invalid
}
```

---

üí° **Summary Table (Practical Use)**

| Principle       | Example Module                               |
| --------------- | -------------------------------------------- |
| SRP             | UserService / PaymentService                 |
| OCP             | PaymentStrategy ‚Üí new gateway addable        |
| LSP             | PaymentStrategy replaceable                  |
| ISP             | IReadable / IWritable                        |
| DIP             | BookingService depends on abstraction        |
| DRY             | AuthService validateToken used everywhere    |
| KISS            | Strategy pattern for payments                |
| YAGNI           | Start with simple roles                      |
| SoC             | Controller / Service / Repository separation |
| Encapsulation   | UserEntity password handling                 |
| Composition     | NotificationService with Email/SMS           |
| Least Knowledge | Controller ‚Üí Service only                    |
| Fail Fast       | DTO validation                               |

---

